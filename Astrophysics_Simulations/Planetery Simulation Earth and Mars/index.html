<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Planetary Orbits — Earth &amp; Mars Simulation</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <header class="site-header">
    <h1>Planetary Orbits: Earth &amp; Mars — 1-year animation</h1>
    <p class="subtitle">A simple 2D velocity-Verlet simulation using <code>numpy</code> and <code>matplotlib</code>.</p>
    <nav class="toc">
      <button data-target="#background" class="nav-btn">Background</button>
      <button data-target="#method" class="nav-btn">Methodology</button>
      <button data-target="#pseudocode" class="nav-btn">Pseudocode</button>
      <button data-target="#code" class="nav-btn">Python Code</button>
      <button data-target="#interpretation" class="nav-btn">Output &amp; Interpretation</button>
    </nav>
  </header>

  <main class="content">
    <section id="summary" class="card">
      <h2>Project summary</h2>
      <p>
        This project simulates the orbital motion of Earth and Mars around the Sun for one year.
        The Sun is treated as a fixed, central mass and each planet is treated as a small test mass.
        The simulation uses the <strong>Velocity-Verlet</strong> integrator which provides good long-term
        stability for conservative gravitational systems.
      </p>
    </section>

    <section id="background" class="card">
      <h2>Scientific background</h2>
      <p><strong>Newton's law of universal gravitation</strong> is the core physical law used:</p>
      <div class="formula">F = G * (M * m) / r<sup>2</sup></div>
      <p>where <em>G</em> is the gravitational constant, <em>M</em> and <em>m</em> are the masses, and <em>r</em> is separation.</p>

      <p>For a test mass m orbiting a dominant mass M (Sun at origin), the acceleration is:</p>
      <div class="formula">a = - G * M * r̂ / r<sup>2</sup> = - G * M / r<sup>3</sup> * r_vector</div>

      <p><strong>Keplerian context:</strong> For circular or near-circular orbits, orbital speed is approximately:</p>
      <div class="formula">v ≈ sqrt(G * M / r)</div>
      <p>In our initial conditions we place Earth and Mars on the +x axis and set their velocity in the +y direction.</p>
    </section>

    <section id="method" class="card">
      <h2>Methodology</h2>
      <h3>Numerical integrator: Velocity-Verlet</h3>
      <p>
        Velocity-Verlet is a second-order symplectic integrator. Each step updates positions using current
        velocities and accelerations, computes new accelerations, then updates velocities using the average
        of old and new accelerations. It's chosen because it conserves energy better over long runs than
        explicit Euler and is easy to implement.
      </p>

      <h3>Assumptions &amp; approximations</h3>
      <ul>
        <li>The Sun is fixed at the origin (no recoil). This is fine if planetary masses ≪ Sun mass.</li>
        <li>Planet-planet gravitational interactions are ignored — this yields independent Keplerian orbits.</li>
        <li>Motion is restricted to a 2D plane (coplanar orbits), ignoring inclinations.</li>
      </ul>

      <h3>Libraries</h3>
      <ul>
        <li><code>numpy</code> — arrays and numeric operations</li>
        <li><code>matplotlib</code> — plotting and animation</li>
      </ul>
    </section>

    <section id="pseudocode" class="card">
      <h2>Pseudocode</h2>
      <pre><code>
SET constants G, M_sun
SET dt, total_time, steps

DEFINE planets with initial radius r0 and tangential speed v0
FOR each planet:
    initialize x = r0, y = 0
    initialize vx = 0, vy = v0
    prepare empty lists for xs, ys

FUNCTION acceleration_from_sun(x, y):
    r2 = x^2 + y^2
    r = sqrt(r2)
    ax = -G * M_sun * x / r^3
    ay = -G * M_sun * y / r^3
    RETURN ax, ay

FOR step in 0..steps-1:
    FOR each planet:
        ax, ay = acceleration_from_sun(x, y)
        x_new = x + vx*dt + 0.5*ax*dt^2
        y_new = y + vy*dt + 0.5*ay*dt^2
        ax_new, ay_new = acceleration_from_sun(x_new, y_new)
        vx_new = vx + 0.5*(ax + ax_new)*dt
        vy_new = vy + 0.5*(ay + ay_new)*dt
        commit x, y, vx, vy = x_new, y_new, vx_new, vy_new
        append x_new, y_new to archive lists

CREATE matplotlib figure and axes (dark theme)
PLOT Sun as a yellow point
CREATE plot objects for each planet (dot + trail)
SETUP animation using FuncAnimation to update dots and trails
SHOW the plot
      </code></pre>
    </section>

    <section id="code" class="card">
      <h2>Full Python code</h2>
      <p>The entire <code>simulation.py</code> script is shown below. Copy it into a file and run with <code>python simulation.py</code>.</p>

      <pre><code>
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation

G = 6.67430e-11            # gravitational constant, m^3 kg^-1 s^-2
M_sun = 1.989e30           # mass of the Sun, kg

dt = 6 * 3600              # time-step: 6 hours in seconds
total_time = 365.25 * 24 * 3600  # one Julian year (approx) in seconds
steps = int(total_time / dt)

anim_interval_ms = 20      # time between frames in milliseconds (for animation playback)
trail_length = None        # how many past positions to draw for each planet (None = full trail)

planets = {
    "Earth": {
        "r0": 1.496e11,    # semi-major axis ~ 1 AU in meters
        "v0": 29.78e3,     # average orbital speed m/s
        "color": "cyan"
    },
    "Mars": {
        "r0": 2.279e11,    # semi-major axis for Mars
        "v0": 24.077e3,    # approximate orbital speed for Mars
        "color": "orange"
    }
}


for p in planets.values():
    p["x"] = p["r0"]
    p["y"] = 0.0
    p["vx"] = 0.0
    p["vy"] = p["v0"]

    p["xs"] = []   # list to collect x positions over time
    p["ys"] = []   # list to collect y positions over time

def acceleration_from_sun(x, y, G=G, M=M_sun):
    """
    Compute gravitational acceleration vector (ax, ay) from the Sun located at origin.
    Uses Newton's law of universal gravitation:
        a = - G * M / r^3 * r_vector
    where r_vector = (x, y) and r = sqrt(x^2 + y^2).

    Returns:
        ax, ay in m/s^2
    """
    r2 = x * x + y * y
    r = np.sqrt(r2)
    
    if r == 0:
        return 0.0, 0.0
    factor = -G * M / (r2 * r)  # equals -G*M / r^3
    ax = factor * x
    ay = factor * y
    return ax, ay


for step in range(steps):
    
    for p in planets.values():
       
        ax, ay = acceleration_from_sun(p["x"], p["y"])

       
        x_new = p["x"] + p["vx"] * dt + 0.5 * ax * dt * dt
        y_new = p["y"] + p["vy"] * dt + 0.5 * ay * dt * dt

        
        ax_new, ay_new = acceleration_from_sun(x_new, y_new)

       
        vx_new = p["vx"] + 0.5 * (ax + ax_new) * dt
        vy_new = p["vy"] + 0.5 * (ay + ay_new) * dt

       
        p["x"], p["y"], p["vx"], p["vy"] = x_new, y_new, vx_new, vy_new

       
        p["xs"].append(p["x"])
        p["ys"].append(p["y"])


def radial_distance_history(p):
    arr = np.sqrt(np.array(p["xs"])**2 + np.array(p["ys"])**2)
    return arr

print("Simulation complete. Summary (final values):")
for name, p in planets.items():
    r_final = np.sqrt(p["x"]**2 + p["y"]**2)
    print(f" - {name}: final r = {r_final:.3e} m, steps simulated = {len(p['xs'])}")



fig, ax = plt.subplots(figsize=(7,7))
ax.set_facecolor("black")
ax.set_aspect("equal", adjustable="box")


orbit_limit = 2.5e11
ax.set_xlim(-orbit_limit, orbit_limit)
ax.set_ylim(-orbit_limit, orbit_limit)


ax.set_title("Sun — Earth — Mars Orbits (Velocity-Verlet)", color="white", fontsize=14, pad=12)
ax.tick_params(colors="white")
for spine in ax.spines.values():
    spine.set_color("white")


sun_dot = ax.scatter(0, 0, color="yellow", s=300, zorder=3, label="Sun")


planet_dots = {}
planet_paths = {}
for name, p in planets.items():
    dot, = ax.plot([], [], "o", color=p["color"], ms=7, label=name, zorder=4)
    path, = ax.plot([], [], "-", color=p["color"], lw=1, alpha=0.8)
    planet_dots[name] = dot
    planet_paths[name] = path


leg = ax.legend(facecolor="#222222", edgecolor="white", labelcolor="white")
for text in leg.get_texts():
    text.set_color("white")

def init():
    for name in planets:
        planet_dots[name].set_data([], [])
        planet_paths[name].set_data([], [])
    return list(planet_dots.values()) + list(planet_paths.values())


def update(frame):
    for name, p in planets.items():
        xs = p["xs"]
        ys = p["ys"]
        N = len(xs)
        if frame >= N:
            idx = N - 1
        else:
            idx = frame

       
        if trail_length is None:
            trail_xs = xs[:idx+1]
            trail_ys = ys[:idx+1]
        else:
            trail_xs = xs[max(0, idx-trail_length+1):idx+1]
            trail_ys = ys[max(0, idx-trail_length+1):idx+1]

        planet_dots[name].set_data([xs[idx]], [ys[idx]])
        planet_paths[name].set_data(trail_xs, trail_ys)

    return list(planet_dots.values()) + list(planet_paths.values())


ani = animation.FuncAnimation(fig, update, frames=steps, init_func=init,
                              blit=True, interval=anim_interval_ms)


plt.show()

</code></pre>

      <p class="note">Note: In this HTML view the Python code is shortened to keep the page readable.</p>

      <button class="toggle-btn" data-target="#explain-block">Show / Hide Line-by-line Explanation</button>

      <div id="explain-block" class="collapsible">
        <h3>Line-by-line / block-by-block explanation (condensed)</h3>
        <p><strong>Imports:</strong> pull in numpy and matplotlib. <br>
           <strong>Constants:</strong> G and M_sun set the physical scale. <br>
           <strong>Initialization:</strong> dt and total_time define temporal resolution and run length. <br>
           <strong>Planets:</strong> each planet holds position, velocity and arrays for trajectories. <br>
           <strong>acceleration_from_sun:</strong> computes -G*M/r^3 * (x,y). <br>
           <strong>Integrator loop:</strong> velocity-verlet update for x and v, storing positions. <br>
           <strong>Animation:</strong> matplotlib FuncAnimation draws moving markers and trails.
        </p>
      </div>
    </section>

    <section id="interpretation" class="card">
      <h2>Expected output &amp; how to interpret</h2>
      <p>
        The animation shows the Sun at the center and the positions of Earth (cyan) and Mars (orange) as they orbit.
        The path lines represent the trajectories accumulated so far in the simulation. For a one-year simulation:
      </p>
      <ul>
        <li>Earth will complete roughly one full revolution (by definition ~1 year).</li>
        <li>Mars will advance along its orbit but completes less than a full revolution in one Earth year (orbital period ≈ 1.88 years).</li>
        <li>You will visually notice Mars' larger orbital radius and longer period.</li>
      </ul>

      <p>If you record the animation or export the final plot, the radius vs. time and energy diagnostics (if added)
         can be used to check numerical accuracy. A symplectic integrator like Velocity-Verlet typically keeps energy
         oscillating around a mean (no secular drift), whereas Euler would show drift over long times.</p>

   
</section>


<section id="animation" class="card">
  <h2>Simulation Animation</h2>
  <p>Click the button below to watch the Earth-Mars orbit animation.</p>
  <button id="openVideoBtn" class="video-btn">Play Animation</button>

  <!-- Video modal overlay -->
  <div id="videoModal" class="video-modal">
    <div class="video-modal-content">
      <span id="closeVideoBtn" class="close-btn">&times;</span>
      <video id="orbitVideo" src="1130.mp4" class="video" controls></video>
    </div>
  </div>
</section>




      
  </main>

  <footer class="site-footer">
    <p>Made for teaching astrophysics &middot; Use and adapt freely. — Simulation uses <code>numpy</code> &amp; <code>matplotlib</code>.</p>
  </footer>

  <script src="script.js"></script>
</body>
</html>
